
        #################################################
        ### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
        #################################################
        # file to edit: dev_nb/006b_pascal.ipynb

from nb_006a import *

class ImageBBox(ImageMask):
    "Image class for bbox-style annotations"
    def clone(self):
        return self.__class__(self.px.clone())

    @classmethod
    def create(cls, bboxes:Collection[Collection[int]], h:int, w:int) -> 'ImageBBox':
        "Creates an ImageBBox object from bboxes"
        pxls = torch.zeros(len(bboxes),h, w).long()
        for i,bbox in enumerate(bboxes):
            pxls[i,bbox[0]:bbox[2]+1,bbox[1]:bbox[3]+1] = 1
        return cls(pxls.float())

    @property
    def data(self) -> LongTensor:
        bboxes = []
        for i in range(self.px.size(0)):
            idxs = torch.nonzero(self.px[i])
            if len(idxs) != 0:
                bboxes.append(torch.tensor([idxs[:,0].min(), idxs[:,1].min(), idxs[:,0].max(), idxs[:,1].max()])[None])
        return torch.cat(bboxes, 0).squeeze()

from matplotlib import patches, patheffects
from matplotlib.patches import Patch

def bb2hw(a:Collection[int]) -> np.ndarray:
    "Converts bounding box points from (width,height,center) to (height,width,top,left)"
    return np.array([a[1],a[0],a[3]-a[1],a[2]-a[0]])

def draw_outline(o:Patch, lw:int):
    "Outlines bounding box onto image `Patch`"
    o.set_path_effects([patheffects.Stroke(
        linewidth=lw, foreground='black'), patheffects.Normal()])

def draw_rect(ax:plt.Axes, b:Collection[int], color:str='white'):
    "Draws bounding box on `ax`"
    patch = ax.add_patch(patches.Rectangle(b[:2], *b[-2:], fill=False, edgecolor=color, lw=2))
    draw_outline(patch, 4)

def _show_image(img:Image, ax:plt.Axes=None, figsize:tuple=(3,3), hide_axis:bool=True, cmap:str='binary',
                alpha:float=None) -> plt.Axes:
    if ax is None: fig,ax = plt.subplots(figsize=figsize)
    ax.imshow(image2np(img), cmap=cmap, alpha=alpha)
    if hide_axis: ax.axis('off')
    return ax

def show_image(x:Image, y:Image=None, ax:plt.Axes=None, figsize:tuple=(3,3), alpha:float=0.5,
               hide_axis:bool=True, cmap:str='viridis'):
    ax1 = _show_image(x, ax=ax, hide_axis=hide_axis, cmap=cmap)
    if y is not None: _show_image(y, ax=ax1, alpha=alpha, hide_axis=hide_axis, cmap=cmap)
    if hide_axis: ax1.axis('off')

def _show(self:Image, ax:plt.Axes=None, y:Image=None, **kwargs):
    if y is not None:
        is_bb = isinstance(y, ImageBBox)
        y=y.data
    if not is_bb: return show_image(self.data, ax=ax, y=y, **kwargs)
    ax = _show_image(self.data, ax=ax)
    if len(y.size()) == 1: draw_rect(ax, bb2hw(y))
    else:
        for i in range(y.size(0)): draw_rect(ax, bb2hw(y[i]))

Image.show = _show

@dataclass
class CoordTargetDataset(Dataset):
    "A dataset with annotated images"
    x_fns:Collection[Path]
    bbs:Collection[Collection[int]]
    def __post_init__(self): assert len(self.x_fns)==len(self.bbs)
    def __repr__(self) -> str: return f'{type(self).__name__} of len {len(self.x_fns)}'
    def __len__(self) -> int: return len(self.x_fns)
    def __getitem__(self, i:int) -> Tuple[Image,ImageBBox]:
        x = open_image(self.x_fns[i])
        return x, ImageBBox.create(self.bbs[i], *x.size)